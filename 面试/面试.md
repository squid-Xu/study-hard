## new 操作符做了什么

-   创建一个空对象
-   空对象的**proto** 指向构造函数的 prototype
-   改变 this 指向
-   判断构造函数的返回值是否为对象，是返回对象，否则返回 obj 对象

```js
function myNew(fn, ...args) {
	let obj = {};
	obj.__proto__ = fn.prototype;
	const result = fn.apply(obj, args);
	return result instanceof Object ? result : obj;
}
```

## 防抖

-   持续执行一个时间，规定时间只触发一次

```js
const debounce = (fn, wait) => {
	let timer = null;
	return (...args) => {
		if (timer) {
			clearTimout(timer);
		}
		timer = setTimeout(() => {
			fn.apply(args);
		}, wait);
	};
};
```

## 节流

-   多长时间执行一次

```js
const throlle = (fn, wait) => {
	let timer = null;
	return (...args) => {
		if (!timer) {
			timer = setTimout(() => {
				timer = null;
				fn.apply(args);
			}, wait);
		}
	};
};
```

## js 继承有哪些

-   原型链继承
    > 通过设置子类的原型为父类的实例

```js
function Person(name, age) {
	this.name = name;
	this.age = age;
}

function child() {}

child.prototype = new Person();
```

-   构造函数继承（借助 call）
    > 通过复制父类的实例属性给子类

```js
function Person(name, age) {
	this.name = name;
	this.age = age;
}

function child() {
	Person.call(this);
}
```

-   组合继承（原型和 call）
    > 通过原型链和构造函数继承

```js
function Person(name, age) {
	this.name = name;
	this.age = age;
}

function child() {
	Person.call(this);
}
child.prototype = new Person();
```

-   class 继承

```js
class Person {
	construct(name, age) {
		this.name = name;
		this.age = age;
	}
}

class child extends Person {
	construct(name, age) {
		super(name, age);
	}
}
```

## 深拷贝

```js
function deepClone(obj) {
	let objClone = Array.isArray(obj) ? [] : {};

	for (let key in obj) {
		if (obj.hasOwnProperty(key)) {
			if (obj[key] instanceof Object) {
				objClone[key] = deepClone(obj[key]);
			} else {
				objClone[key] = obj[key];
			}
		}
	}
	return objClone;
}
```

## Vue 中的模板编译原理？

-   解析： Vue 将模板字符串转换成抽象语法树。在这个过程中，Vue 会识别模板中的各种元素，包括普通 HTML 标签、指令、插值表达式，并将它们转 换成抽象语法树；
-   优化：Vue 会对抽象语法树进行优化，比如静态节点提升、静态属性提升等，以减少运行时的开销；
-   代码生成：最后 Vue 会遍历抽象语法树，并根据抽象语法树生成一个渲染函数。这个函数会接收一个数据对象作为参数，并返回一个虚拟 DOM。Vue 运行时，会调用这个函数，传入当前的数据对象，从而生成对应的虚拟 DOM 节点；
